<!DOCTYPE html>
<meta charset="UTF-8"content="">

<title>&nbsp;{{ page|capfirst }}</title>
<link rel="icon" type="image/x-icon" href="/static/images/house-door-fill-matcha.svg">

<!-- set viewport for mobile devices -->
<meta name="viewport" content="width = device-width, initial-scale = 1">

<!-- bootstrap stylesheets -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

<!-- bootstrap icons -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<!-- project stylesheets -->
<link rel="stylesheet" href="/static/css/base-colors.css">
<link rel="stylesheet"  href="/static/css/base-app.css">
<link rel="stylesheet" href="/static/css/base-forms.css">
<link rel="stylesheet" href="/static/css/base-nav.css">
<link rel="stylesheet" href="/static/css/app-folders.css">
{% if page %}
  <link rel="stylesheet" href="/static/css/app-{{page}}.css">
{% endif %}
{% if user.theme %}
  <link rel="stylesheet" href="/static/css/theme-{{ user.theme }}.css">
{% endif %}


{% include 'nav.html' %}

<div class="container" id="content">

  {% block content %}

  {% endblock content %}

</div>

</body>


<!-- javascript -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="/static/js/main.js"></script>
<script src="/static/js/folders.js"></script>

{% if page and page == "home" and moved_folder %}
  <script type="text/javascript">
    window.onload = showHideHomeControls({{ moved_folder }});
  </script>
{% endif %}

{% if page and page == "home" %}
<script>
// Folder drag-and-drop functionality
let draggedFolder = null;

// Initialize drag functionality when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeDragDrop();
});

function initializeDragDrop() {
    // Get drag handles and folders
    const dragHandles = document.querySelectorAll('.drag-handle');
    const folders = document.querySelectorAll('.folder');
    const dropZones = document.querySelectorAll('.drop-zone');
    
    
    // Set up folders as drop targets only (not draggable)
    folders.forEach((folder, index) => {
        folder.draggable = false; // Never draggable
        
        // Create extended drop zone for each folder
        createExtendedDropZone(folder, index);
        
        // Add folder event listeners (drop only, not drag)
        folder.addEventListener('dragover', handleFolderDragOver);
        folder.addEventListener('drop', handleFolderDrop);
    });
    
    // Continue with the rest of initialization
    continueInitialization(dragHandles, dropZones);
    
    // Initialize favorite link drag-and-drop
    initializeFavoriteDragDrop();
}

function createExtendedDropZone(folder, index) {
    // Create an invisible extended drop zone that covers the gap below each folder
    const extendedZone = document.createElement('div');
    extendedZone.className = 'folder-extended-drop-zone';
    extendedZone.style.position = 'absolute';
    extendedZone.style.left = '0';
    extendedZone.style.right = '0';
    extendedZone.style.height = '2rem'; // Cover the full gap below (was margin-bottom: 2rem)
    extendedZone.style.top = '100%';
    extendedZone.style.zIndex = '10';
    
    // Copy folder data attributes to the extended zone
    extendedZone.setAttribute('data-folder-id', folder.getAttribute('data-folder-id'));
    extendedZone.setAttribute('data-current-column', folder.getAttribute('data-current-column'));
    
    // Add event listeners for the extended zone
    extendedZone.addEventListener('dragover', handleFolderDragOver);
    extendedZone.addEventListener('drop', handleFolderDrop);
    
    // Position the folder relatively and append the extended zone
    folder.style.position = 'relative';
    folder.appendChild(extendedZone);
    
}

function continueInitialization(dragHandles, dropZones) {
    // Make only the drag handles draggable
    dragHandles.forEach((handle, index) => {
        handle.draggable = true;
        
        // Add drag handle event listeners
        handle.addEventListener('dragstart', handleDragHandleDragStart);
        handle.addEventListener('dragend', handleDragHandleDragEnd);
    });
    
    // Calculate optimal drop zone height
    const viewportHeight = window.innerHeight;
    const favoritesSection = document.querySelector('.row.align-items-start');
    const favoritesTop = favoritesSection ? favoritesSection.getBoundingClientRect().top : 200;
    const optimalHeight = Math.max(600, viewportHeight - favoritesTop - 40); // 40px bottom padding
    
    
    // Add drop zone event listeners
    dropZones.forEach((zone, index) => {
        // Set dynamic height based on available space
        zone.style.minHeight = optimalHeight + 'px';
        
        zone.addEventListener('dragover', handleDragOver);
        zone.addEventListener('dragenter', handleDragEnter);
        zone.addEventListener('dragleave', handleDragLeave);
        zone.addEventListener('drop', handleDrop);
    });
}

function handleDragHandleDragStart(e) {
    // Find the parent folder
    const folder = this.closest('.folder');
    
    if (folder) {
        draggedFolder = folder;
        folder.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', folder.outerHTML);
    }
}

function handleDragHandleDragEnd(e) {
    // Find the parent folder
    const folder = this.closest('.folder');
    if (folder) {
        folder.classList.remove('dragging', 'drag-enabled');
    }
    
    // Remove drag-over class from all drop zones and folders
    const dropZones = document.querySelectorAll('.drop-zone');
    dropZones.forEach(zone => {
        zone.classList.remove('drag-over', 'drop-zone-active');
    });
    
    const folders = document.querySelectorAll('.folder');
    folders.forEach(folder => {
        folder.classList.remove('drag-over-top', 'drag-over-bottom', 'drop-target-active');
    });
}

function initializeFavoriteDragDrop() {
    const favoriteLinks = document.querySelectorAll('.favorite-drag-link');
    const favoriteItems = document.querySelectorAll('.favorite-item');
    
    
    // Set up favorite items (list items) with drag and click behavior
    favoriteItems.forEach((item, index) => {
        const link = item.querySelector('.favorite-drag-link');
        if (!link) return;
        
        let dragTimeout;
        let isDragging = false;
        
        // Mouse down on the item starts potential drag
        item.addEventListener('mousedown', function(e) {
            dragTimeout = setTimeout(() => {
                // After delay, enable dragging on the item
                item.draggable = true;
                isDragging = true;
                item.style.cursor = 'grabbing';
            }, 150); // 150ms delay before drag starts
        });
        
        // Mouse up cancels drag or allows navigation
        item.addEventListener('mouseup', function(e) {
            clearTimeout(dragTimeout);
            if (!isDragging) {
                // Short click - check if it was on the link for navigation
                if (e.target === link || link.contains(e.target)) {
                    window.location.href = link.href;
                }
            } else {
                // Was dragging - clean up
                item.draggable = false;
                isDragging = false;
                item.style.cursor = '';
            }
        });
        
        // Prevent default link behavior during drag
        link.addEventListener('click', function(e) {
            if (isDragging) {
                e.preventDefault();
                return false;
            }
        });
        
        // Drag events on the item
        item.addEventListener('dragstart', function(e) {
            handleFavoriteDragStart.call(link, e); // Call with link context
        });
        item.addEventListener('dragend', function(e) {
            handleFavoriteDragEnd.call(link, e); // Call with link context
        });
    });
    
    // Set up favorite items as drop targets - dropping on any link positions below it
    favoriteItems.forEach((item, index) => {
        item.addEventListener('dragover', handleFavoriteDragOver);
        item.addEventListener('drop', handleFavoriteDrop);
        item.addEventListener('dragenter', function(e) {
            e.preventDefault();
        });
        
        // Style for better drop targeting
        item.style.minHeight = '2rem'; // Make drop target bigger
        item.style.display = 'flex';
        item.style.alignItems = 'center';
    });
}

function createFavoriteExtendedDropZone(favoriteItem, index) {
    // Create an invisible extended drop zone that covers the gap below each favorite
    const extendedZone = document.createElement('div');
    extendedZone.className = 'favorite-extended-drop-zone';
    extendedZone.style.position = 'absolute';
    extendedZone.style.left = '0';
    extendedZone.style.right = '0';
    extendedZone.style.height = '0.5rem';
    extendedZone.style.top = '100%';
    extendedZone.style.zIndex = '10';
    
    // Copy favorite data attributes to the extended zone
    extendedZone.setAttribute('data-favorite-id', favoriteItem.getAttribute('data-favorite-id'));
    extendedZone.setAttribute('data-folder-id', favoriteItem.getAttribute('data-folder-id'));
    
    // Add event listeners for the extended zone
    extendedZone.addEventListener('dragover', handleFavoriteDragOver);
    extendedZone.addEventListener('drop', handleFavoriteDrop);
    
    // Position the favorite item relatively and append the extended zone
    favoriteItem.style.position = 'relative';
    favoriteItem.appendChild(extendedZone);
}

let draggedFavorite = null;

function handleFavoriteDragStart(e) {
    draggedFavorite = this;
    const favoriteItem = this.closest('.favorite-item');
    if (favoriteItem) {
        favoriteItem.classList.add('dragging');
        // Disable drop events on the dragged item to prevent conflicts
        favoriteItem.style.pointerEvents = 'none';
    }
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.outerHTML);
}

function handleFavoriteDragEnd(e) {
    const favoriteItem = this.closest('.favorite-item');
    if (favoriteItem) {
        favoriteItem.classList.remove('dragging');
        // Re-enable pointer events
        favoriteItem.style.pointerEvents = '';
    }
    favoriteItem.draggable = false;
    favoriteItem.style.cursor = '';
    draggedFavorite = null;
}

function handleFavoriteDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleFavoriteDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    
    // Don't allow dropping on self
    if (this === draggedFavorite?.closest('.favorite-item')) {
        return false;
    }
    
    if (draggedFavorite !== null) {
        const draggedFavoriteId = draggedFavorite.getAttribute('data-favorite-id');
        const draggedFolderId = draggedFavorite.getAttribute('data-folder-id');
        const targetFavoriteId = this.getAttribute('data-favorite-id');
        const targetFolderId = this.getAttribute('data-folder-id');
        
        // Validate IDs before making API call
        if (!draggedFavoriteId || !targetFavoriteId) {
            return false;
        }
        
        if (draggedFolderId === targetFolderId) {
            // Same folder - place below the target favorite
            insertFavoriteBelowFavorite(draggedFavoriteId, targetFavoriteId);
        } else {
            // Cross-folder drop - move to new folder and place below target
            moveFavoriteToNewFolder(draggedFavoriteId, targetFavoriteId, targetFolderId);
        }
    }
    
    return false;
}


function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDragEnter(e) {
    this.classList.add('drag-over');
}

function handleDragLeave(e) {
    this.classList.remove('drag-over');
}

function handleFolderDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    
    // Don't allow dropping on self
    if (this === draggedFolder) {
        return false;
    }
    
    // Clear previous hover states
    const folders = document.querySelectorAll('.folder');
    folders.forEach(folder => {
        folder.classList.remove('drag-over-top', 'drag-over-bottom');
    });
    
    // Determine if we're in the top or bottom half of the folder
    const rect = this.getBoundingClientRect();
    const midY = rect.top + rect.height / 2;
    
    if (e.clientY < midY) {
        this.classList.add('drag-over-top');
    } else {
        this.classList.add('drag-over-bottom');
    }
    
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleFolderDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    
    // Don't allow dropping on self
    if (this === draggedFolder) {
        return false;
    }
    
    if (draggedFolder !== null) {
        const draggedFolderId = draggedFolder.getAttribute('data-folder-id');
        const draggedColumn = parseInt(draggedFolder.getAttribute('data-current-column'));
        const targetFolderId = this.getAttribute('data-folder-id');
        const targetColumn = parseInt(this.getAttribute('data-current-column'));
        
        // Check if we're dropping on an extended drop zone (the green gap area)
        const isExtendedZone = this.classList.contains('folder-extended-drop-zone');
        
        
        if (draggedColumn === targetColumn) {
            // Same column
            if (isExtendedZone) {
                // Dropping in gap - place below the target folder
                insertBelowFolder(draggedFolderId, targetFolderId, targetColumn);
            } else {
                // Dropping on folder - swap positions
                swapFolderPositions(draggedFolderId, targetFolderId);
            }
        } else {
            // Cross-column drop
            if (isExtendedZone) {
                // Dropping in gap - place below the target folder
                insertBelowFolder(draggedFolderId, targetFolderId, targetColumn);
            } else {
                // Dropping on folder - insert at target folder's position
                insertFolderAtPosition(draggedFolderId, targetFolderId, targetColumn);
            }
        }
    }
    
    return false;
}

function handleDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    
    this.classList.remove('drag-over');
    
    if (draggedFolder !== null) {
        const folderId = draggedFolder.getAttribute('data-folder-id');
        const targetColumn = this.getAttribute('data-column');
        const currentColumn = draggedFolder.getAttribute('data-current-column');
        
        if (targetColumn !== currentColumn) {
            // Calculate position at end of column
            const foldersInColumn = this.querySelectorAll('.folder').length;
            // Update folder column via AJAX
            updateFolderColumn(folderId, targetColumn, foldersInColumn);
        }
    }
    
    return false;
}

function swapFolderPositions(draggedFolderId, targetFolderId) {
    const formData = new FormData();
    formData.append('dragged_folder_id', draggedFolderId);
    formData.append('target_folder_id', targetFolderId);
    formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
    
    fetch('/home/swap-folder-positions/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Reload the page to reflect the changes
            window.location.reload();
        } else {
            console.error('Error swapping folders:', data.error);
            alert('Error swapping folders: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error swapping folders');
    });
}

function insertBelowFolder(draggedFolderId, targetFolderId, targetColumn) {
    const formData = new FormData();
    formData.append('dragged_folder_id', draggedFolderId);
    formData.append('target_folder_id', targetFolderId);
    formData.append('target_column', targetColumn);
    formData.append('insert_below', 'true');
    formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
    
    fetch('/home/insert-folder-at-position/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Reload the page to reflect the changes
            window.location.reload();
        } else {
            console.error('Error inserting folder below:', data.error);
            alert('Error inserting folder below: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error inserting folder below');
    });
}

function insertFolderAtPosition(draggedFolderId, targetFolderId, targetColumn) {
    const formData = new FormData();
    formData.append('dragged_folder_id', draggedFolderId);
    formData.append('target_folder_id', targetFolderId);
    formData.append('target_column', targetColumn);
    formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
    
    fetch('/home/insert-folder-at-position/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Reload the page to reflect the changes
            window.location.reload();
        } else {
            console.error('Error inserting folder:', data.error);
            alert('Error inserting folder: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error inserting folder');
    });
}

function updateFolderColumn(folderId, targetColumn, targetPosition) {
    const formData = new FormData();
    formData.append('folder_id', folderId);
    formData.append('target_column', targetColumn);
    if (targetPosition !== undefined) {
        formData.append('target_position', targetPosition);
    }
    formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
    
    fetch('/home/update-folder-column/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Reload the page to reflect the changes
            window.location.reload();
        } else {
            console.error('Error moving folder:', data.error);
            alert('Error moving folder: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error moving folder');
    });
}


function swapFavoritePositions(draggedFavoriteId, targetFavoriteId) {
    const formData = new FormData();
    formData.append('dragged_favorite_id', draggedFavoriteId);
    formData.append('target_favorite_id', targetFavoriteId);
    formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
    
    fetch('/home/swap-favorite-positions/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Reload the page to reflect the changes
            window.location.reload();
        } else {
            console.error('Error swapping favorites:', data.error);
            alert('Error swapping favorites: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error swapping favorites');
    });
}

function insertFavoriteBelowFavorite(draggedFavoriteId, targetFavoriteId) {
    const formData = new FormData();
    formData.append('dragged_favorite_id', draggedFavoriteId);
    formData.append('target_favorite_id', targetFavoriteId);
    formData.append('insert_below', 'true');
    formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
    
    fetch('/home/insert-favorite-at-position/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.reload();
        } else {
            console.error('Error inserting favorite:', data.error);
            alert('Error inserting favorite: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error inserting favorite');
    });
}

function moveFavoriteToNewFolder(draggedFavoriteId, targetFavoriteId, targetFolderId) {
    const formData = new FormData();
    formData.append('dragged_favorite_id', draggedFavoriteId);
    formData.append('target_favorite_id', targetFavoriteId);
    formData.append('target_folder_id', targetFolderId);
    formData.append('csrfmiddlewaretoken', getCookie('csrftoken'));
    
    fetch('/home/move-favorite-to-folder/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.reload();
        } else {
            console.error('Error moving favorite:', data.error);
            alert('Error moving favorite: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error moving favorite');
    });
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
</script>
{% endif %}


