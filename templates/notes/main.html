{% extends "base.html" %}
{% load cache_buster %}
{% block content %}
    <div id="notes"
         {% if user.encryption_salt %}data-encryption-salt="{{ user.encryption_salt }}"{% endif %}
         hx-trigger="notesChanged from:body, foldersChanged from:body"
         hx-get="{% url 'notes:list' %}"
         hx-target="this">{% include "notes/list.html" %}</div>
    <script type="module">
    import { encrypt, decrypt, deriveKey, hasFreshKey, refreshKeyTimestamp, getStoredKey, storeKey, KEY_TTL_MS } from "{% static_v 'js/crypto.js' %}";

    function getCSRFToken() {
      const el = document.querySelector("[name=csrfmiddlewaretoken]");
      if (el) return el.value;
      // Fall back to htmx header on body
      const hxHeaders = document.body.getAttribute("hx-headers");
      if (hxHeaders) {
        try { return JSON.parse(hxHeaders)["X-CSRFToken"]; } catch (e) {}
      }
      return "";
    }

    async function getEncryptionKey(salt) {
      if (hasFreshKey(KEY_TTL_MS)) {
        try {
          const key = await getStoredKey();
          refreshKeyTimestamp();
          return key;
        } catch (e) { /* fall through to prompt */ }
      }

      // Prompt for passphrase
      return new Promise(function(resolve) {
        const overlay = document.createElement("div");
        overlay.className = "passphrase-dialog-overlay";
        overlay.innerHTML =
          '<div class="passphrase-dialog">' +
            '<p>Enter your passphrase:</p>' +
            '<div class="password-wrapper">' +
              '<input type="password" class="form-control" placeholder="Passphrase" autocomplete="off">' +
              '<button type="button" class="password-toggle" tabindex="-1" aria-label="Toggle visibility">' +
                '<i class="icon-eye-off"></i>' +
              '</button>' +
            '</div>' +
            '<p class="unlock-error" id="dialog-error"></p>' +
            '<div class="passphrase-dialog-actions">' +
              '<button type="button" class="btn btn-secondary btn-slim dialog-cancel">Cancel</button>' +
              '<button type="button" class="btn btn-primary btn-slim dialog-confirm">OK</button>' +
            '</div>' +
          '</div>';

        document.body.appendChild(overlay);
        const input = overlay.querySelector("input");
        const confirmBtn = overlay.querySelector(".dialog-confirm");
        const cancelBtn = overlay.querySelector(".dialog-cancel");
        const errorEl = overlay.querySelector("#dialog-error");
        const toggle = overlay.querySelector(".password-toggle");

        if (toggle) {
          toggle.addEventListener("click", function() {
            const ico = toggle.querySelector("i");
            if (input.type === "password") { input.type = "text"; ico.className = "icon-eye"; }
            else { input.type = "password"; ico.className = "icon-eye-off"; }
          });
        }

        function cleanup() { overlay.remove(); }

        async function doConfirm() {
          const passphrase = input.value;
          if (!passphrase) { errorEl.textContent = "Please enter a passphrase."; return; }
          confirmBtn.disabled = true;
          errorEl.textContent = "";
          try {
            const key = await deriveKey(passphrase, salt);
            await storeKey(key);
            cleanup();
            resolve(key);
          } catch (e) {
            errorEl.textContent = "Error deriving key.";
            confirmBtn.disabled = false;
          }
        }

        confirmBtn.addEventListener("click", doConfirm);
        input.addEventListener("keydown", function(e) {
          if (e.key === "Enter") doConfirm();
          if (e.key === "Escape") { cleanup(); resolve(null); }
        });
        cancelBtn.addEventListener("click", function() { cleanup(); resolve(null); });
        overlay.addEventListener("click", function(e) {
          if (e.target === overlay) { cleanup(); resolve(null); }
        });
        setTimeout(function() { input.focus(); }, 50);
      });
    }

    async function fetchNoteContent(noteId) {
      const resp = await fetch("{% url 'settings-encryption-notes' %}", {
        headers: { "X-CSRFToken": getCSRFToken() },
      });
      const data = await resp.json();
      return data.notes.find(function(n) { return n.id === noteId; });
    }

    async function saveNote(url, content, isEncrypted) {
      const formData = new FormData();
      formData.append("content", content);
      formData.append("is_encrypted", isEncrypted ? "true" : "false");
      const resp = await fetch(url, {
        method: "POST",
        headers: { "X-CSRFToken": getCSRFToken() },
        body: formData,
      });
      return resp.ok;
    }

    document.addEventListener("click", async function(e) {
      const link = e.target.closest(".note-encrypt-toggle");
      if (!link) return;
      e.preventDefault();

      const noteId = parseInt(link.dataset.noteId, 10);
      const isEncrypted = link.dataset.encrypted === "true";
      const autosaveUrl = link.dataset.autosaveUrl;
      const salt = document.getElementById("notes")?.dataset.encryptionSalt;

      if (!isEncrypted) {
        // Encrypt the note
        if (!salt) {
          await window.showConfirm({
            title: "Encryption Not Set Up",
            message: "Go to Settings > Encryption to set a passphrase before encrypting notes.",
            confirmText: "OK",
            isDangerous: false,
          });
          return;
        }

        const key = await getEncryptionKey(salt);
        if (!key) return;

        const note = await fetchNoteContent(noteId);
        if (!note) return;

        const encrypted = note.content ? await encrypt(note.content, key) : "";
        if (await saveNote(autosaveUrl, encrypted, true)) {
          htmx.trigger(document.body, "notesChanged");
        }
      } else {
        // Remove encryption: decrypt the note
        if (!salt) return;

        const confirmed = await window.showConfirm({
          title: "Remove Encryption",
          message: "This will decrypt this note and save the content as plaintext.",
          confirmText: "Remove Encryption",
          isDangerous: true,
        });
        if (!confirmed) return;

        const key = await getEncryptionKey(salt);
        if (!key) return;

        const note = await fetchNoteContent(noteId);
        if (!note) return;

        try {
          const plaintext = note.content ? await decrypt(note.content, key) : "";
          if (await saveNote(autosaveUrl, plaintext, false)) {
            htmx.trigger(document.body, "notesChanged");
          }
        } catch (e) {
          await window.showConfirm({
            title: "Decryption Failed",
            message: "Could not decrypt this note. The passphrase may be incorrect.",
            confirmText: "OK",
            isDangerous: false,
          });
        }
      }
    });

    // =========================================================================
    // Multi-select / Bulk Actions
    // =========================================================================

    const selectedNoteIds = new Set();

    function setIconChecked(icon, checked) {
      if (checked) {
        icon.classList.remove("icon-square");
        icon.classList.add("icon-square-check");
      } else {
        icon.classList.remove("icon-square-check");
        icon.classList.add("icon-square");
      }
    }

    function isIconChecked(icon) {
      return icon.classList.contains("icon-square-check");
    }

    function updateSelectionUI() {
      const normalToolbar = document.getElementById("notes-normal-toolbar");
      const bulkToolbar = document.getElementById("notes-bulk-toolbar");
      if (!normalToolbar || !bulkToolbar) return;

      const hasSelection = selectedNoteIds.size > 0;
      normalToolbar.style.display = hasSelection ? "none" : "";
      bulkToolbar.style.display = hasSelection ? "" : "none";

      // Update count label
      const countEl = bulkToolbar.querySelector(".bulk-count");
      if (countEl) countEl.textContent = selectedNoteIds.size + " selected";

      // Reset move folder dropdown
      const moveSelect = document.getElementById("bulk-move-folder");
      if (moveSelect) moveSelect.selectedIndex = 0;

      // Sync icons with selection state (after HTMX swaps)
      document.querySelectorAll(".note-select-checkbox").forEach(function(icon) {
        setIconChecked(icon, selectedNoteIds.has(icon.dataset.value));
      });

      // Update select-all icon
      const selectAll = document.getElementById("select-all-notes");
      if (selectAll) {
        const icons = document.querySelectorAll(".note-select-checkbox");
        const total = icons.length;
        const checked = Array.from(icons).filter(function(i) { return isIconChecked(i); }).length;
        setIconChecked(selectAll, total > 0 && checked === total);
      }
    }

    // Event delegation for icon clicks
    document.getElementById("notes").addEventListener("click", function(e) {
      if (e.target.id === "select-all-notes") {
        const willCheck = !isIconChecked(e.target);
        document.querySelectorAll(".note-select-checkbox").forEach(function(icon) {
          if (willCheck) selectedNoteIds.add(icon.dataset.value);
          else selectedNoteIds.delete(icon.dataset.value);
        });
        updateSelectionUI();
        return;
      }

      if (e.target.classList.contains("note-select-checkbox")) {
        const val = e.target.dataset.value;
        if (selectedNoteIds.has(val)) selectedNoteIds.delete(val);
        else selectedNoteIds.add(val);
        updateSelectionUI();
      }
    });

    // Re-apply selection state after HTMX table swaps
    document.addEventListener("htmx:afterSettle", function(e) {
      if (e.detail.target && (e.detail.target.id === "notes" || e.detail.target.id === "notes-table")) {
        updateSelectionUI();
      }
    });

    // Clear selection on notesChanged
    document.body.addEventListener("notesChanged", function() {
      selectedNoteIds.clear();
      updateSelectionUI();
    });

    // Cancel button
    document.addEventListener("click", function(e) {
      if (e.target.closest("#bulk-cancel-btn")) {
        selectedNoteIds.clear();
        updateSelectionUI();
      }
    });

    // Bulk delete
    document.addEventListener("click", async function(e) {
      if (!e.target.closest("#bulk-delete-btn")) return;
      const ids = Array.from(selectedNoteIds);
      if (!ids.length) return;

      const confirmed = await window.showConfirm({
        title: "Delete Notes",
        message: "Are you sure you want to delete " + ids.length + " note" + (ids.length > 1 ? "s" : "") + "?",
        confirmText: "Delete",
        isDangerous: true,
      });
      if (!confirmed) return;

      await fetch("{% url 'notes:bulk-delete' %}", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRFToken": getCSRFToken() },
        body: JSON.stringify({ note_ids: ids.map(Number) }),
      });
      selectedNoteIds.clear();
      htmx.trigger(document.body, "notesChanged");
    });

    // Bulk move folder
    document.addEventListener("change", async function(e) {
      const select = e.target.closest("#bulk-move-folder");
      if (!select) return;
      const ids = Array.from(selectedNoteIds);
      if (!ids.length) return;

      const folderId = select.value === "null" ? null : Number(select.value);
      await fetch("{% url 'notes:bulk-move-folder' %}", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRFToken": getCSRFToken() },
        body: JSON.stringify({ note_ids: ids.map(Number), folder_id: folderId }),
      });
      selectedNoteIds.clear();
      htmx.trigger(document.body, "notesChanged");
    });

    // Bulk encrypt
    document.addEventListener("click", async function(e) {
      if (!e.target.closest("#bulk-encrypt-btn")) return;
      const salt = document.getElementById("notes")?.dataset.encryptionSalt;
      if (!salt) {
        await window.showConfirm({
          title: "Encryption Not Set Up",
          message: "Go to Settings > Encryption to set a passphrase before encrypting notes.",
          confirmText: "OK",
          isDangerous: false,
        });
        return;
      }

      const key = await getEncryptionKey(salt);
      if (!key) return;

      // Fetch all notes to get content
      const resp = await fetch("{% url 'settings-encryption-notes' %}", {
        headers: { "X-CSRFToken": getCSRFToken() },
      });
      const data = await resp.json();
      const allNotes = data.notes || [];

      // Filter to selected, unencrypted notes
      const toEncrypt = allNotes.filter(function(n) {
        return selectedNoteIds.has(String(n.id)) && !n.is_encrypted;
      });

      if (!toEncrypt.length) {
        await window.showConfirm({
          title: "Nothing to Encrypt",
          message: "All selected notes are already encrypted.",
          confirmText: "OK",
          isDangerous: false,
        });
        return;
      }

      // Encrypt each note
      const updates = [];
      for (const note of toEncrypt) {
        const encrypted = note.content ? await encrypt(note.content, key) : "";
        updates.push({ id: note.id, content: encrypted, is_encrypted: true });
      }

      await fetch("{% url 'settings-encryption-notes-update' %}", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRFToken": getCSRFToken() },
        body: JSON.stringify({ notes: updates }),
      });

      selectedNoteIds.clear();
      htmx.trigger(document.body, "notesChanged");
    });

    // Bulk decrypt
    document.addEventListener("click", async function(e) {
      if (!e.target.closest("#bulk-decrypt-btn")) return;
      const salt = document.getElementById("notes")?.dataset.encryptionSalt;
      if (!salt) return;

      const confirmed = await window.showConfirm({
        title: "Remove Encryption",
        message: "This will decrypt the selected notes and save them as plaintext.",
        confirmText: "Remove Encryption",
        isDangerous: true,
      });
      if (!confirmed) return;

      const key = await getEncryptionKey(salt);
      if (!key) return;

      // Fetch all notes to get content
      const resp = await fetch("{% url 'settings-encryption-notes' %}", {
        headers: { "X-CSRFToken": getCSRFToken() },
      });
      const data = await resp.json();
      const allNotes = data.notes || [];

      // Filter to selected, encrypted notes
      const toDecrypt = allNotes.filter(function(n) {
        return selectedNoteIds.has(String(n.id)) && n.is_encrypted;
      });

      if (!toDecrypt.length) {
        await window.showConfirm({
          title: "Nothing to Decrypt",
          message: "None of the selected notes are encrypted.",
          confirmText: "OK",
          isDangerous: false,
        });
        return;
      }

      // Decrypt each note
      const updates = [];
      let failCount = 0;
      for (const note of toDecrypt) {
        try {
          const plaintext = note.content ? await decrypt(note.content, key) : "";
          updates.push({ id: note.id, content: plaintext, is_encrypted: false });
        } catch (err) {
          failCount++;
        }
      }

      if (updates.length > 0) {
        await fetch("{% url 'settings-encryption-notes-update' %}", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-CSRFToken": getCSRFToken() },
          body: JSON.stringify({ notes: updates }),
        });
      }

      if (failCount > 0) {
        await window.showConfirm({
          title: "Decryption Partially Failed",
          message: failCount + " note" + (failCount > 1 ? "s" : "") + " could not be decrypted. The passphrase may be incorrect.",
          confirmText: "OK",
          isDangerous: false,
        });
      }

      selectedNoteIds.clear();
      htmx.trigger(document.body, "notesChanged");
    });
    </script>
{% endblock content %}
